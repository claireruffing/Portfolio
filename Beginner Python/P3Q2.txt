#Minesweeper is a single-player game in which the player continuously selects different cells of an m n grid. 
#Each cell of the grid is either occupied by a bomb or is a safe cell. If a cell is occupied by a bomb and the player selects the cell, 
#the player loses. Otherwise, the selected cell shows the number of bombs in the neighboring cells. 
#A neighbor cell is a cell next to the current cell in the horizontal, vertical, and diagonal direction.

#Write a program that receives in the first input line “m” and “n” as the number of rows and columns of the grid, respectively. 
#In the second line, the user inputs an integer, “b”, showing the number of bombs placed in the grid. 
#It then follows by lines of input from the user, each referring to the row and column index of each one of the bombs.

#After receiving grid dimensions, the number of bombs, and bomb locations, you will need to display (print) the completed grid 
#showing the bomb cells with * and safe cells with the number of safe cells neighboring that cell.

#Note: In a regular minesweeper game, the integers in the grid denote the number of bombs in the neighboring cells. 
#We have changed it to the number of safe cells for the purpose of this question only.
#Examples:
#Input:
#2 2
#2
#0 0
#1 1

#Output:
#*1
#1*

#Input:
#3 2
#1
#0 1

#Output:
#2 *
#4 4
#3 3


import numpy

def num_safe_cells(r, c):
    for row in table:
        for item in row:
            if(item != '*'):
                print('yes')
    
                    

r_c = input().split()   #first line of input is number of rows and columns
b = int(input())             #number of bombs

r = int(r_c[0])   #row from input
c = int(r_c[1])   #column from input

table = numpy.zeros((r,c), dtype=str)   #table of rows and columns filled with zeros

list_bc = []        #list of bomb cells
for i in range(0,b):
    list_bc.append(input())        #placing the positions of the bombs in a list

bomb = '*'



#putting a * in the cells that have bombs
for i in list_bc:
    bomb_loc = i.split()        #cell location of the bomb
    row = int(bomb_loc[0])
    col = int(bomb_loc[1])
    table[row][col] = '*'  
        
list_result = []
#counting the neighboring safe cells        
for i in range(0, r):
    for j in range(0, c):
        count = 0
        if(table[i][j] == '*'):
            list_result.append('*')
        elif(table[i][j] != '*'):
            if((i-1)>=0 and (j-1)>=0 and (table[i-1][j-1] != '*')):   
                count += 1
            if((i-1)>=0 and (table[i-1][j] != '*')):
                count += 1
            if((i-1)>=0 and (j+1)<c and (table[i-1][j+1] != '*')):   
                count += 1
            if((j-1)>=0 and (table[i][j-1] != '*')):   
                count += 1
            if((j+1)<c and (table[i][j+1] != '*')):   
                count += 1
            if((i+1)<r and (j-1)>=0 and (table[i+1][j-1] != '*')):   
                count += 1
            if((i+1)<r and (table[i+1][j] != '*')):   
                count += 1
            if((i+1)<r and (j+1)<c and (table[i+1][j+1] != '*')):   
                count += 1
            list_result.append(count)
            

x = 0
counter = 0
for x in range(len(list_result)):
    if(counter == c-1):
        print(list_result[x])
        counter = 0
    elif(x == len(list_result)-1):
        print(list_result[x])
    else:
        print(list_result[x], end='')
        x += 1
        counter += 1
        