#Construct a class “Monster” with the following attributes:

#self.name (a string)
#self.type (a string, default is ‘Normal’)
#self.current_hp (int, start out equal to max_hp)
#self.max_hp ( int, is given as input when the class instance is created, default is 20)
#self.attacks (a dictionary of all known attacks)
#self. possible_attacks ( a dictionary of all possible attacks)
#The dictionary of possible_attacks will map the name of an attack ( the key) to how many points of damage the attack does.
# They must be of the following list:

#sneak_attack: 1
#slash: 2
#ice_storm: 3
#fire_storm: 3
#whirlwind: 3
#earthquake: 2
#double_hit: 4
#tornado: 4
#wait: 0
#Every monster will start out with only the “wait” attack within self.attacks.

#You will need to construct the method add_attack and remove_attack. Both methods will take in an attack name as a parameter.
# A monster can only have a maximum of four attacks at a time. If you add an attack when the monster already has four, the weakest one 
#should be dropped automatically. If there is a tie for the weakest attack, drop the attack that comes first alphabetically. 
#If adding the attack ended successfully, return True. If you try to add an invalid attack return False. If all of a monster’s attacks 
#are removed, “wait” should automatically be added again, so that every monster always has at least 1 attack. 
#If removing an attack ended successfully return True. If you try to remove an invalid attack or an attack that has not been learned 
#return False.


class Monster():
    def __init__(self, name, ty='Normal', maxhp=20):
        self.exp = 0
        #your code here
        self.name = name
        self.type = ty
        self.max_hp = maxhp
        self.current_hp = self.max_hp
        self.attacks = { 
            'wait' : 0
        }
        self.possible_attacks = {
            'sneak_attack' : 1,
            'slash' : 2,
            'ice_storm' : 3,
            'fire_storm' : 3,
            'whirlwind' : 3,
            'earthquake' : 2,
            'double_hit' : 4,
            'tornado' : 4,
            'wait' : 0
        }
            
            
    def add_attack(self, attack_name):
        #check if this string attack_name is in self.possible_attacks.key() (Note: .item() returns the key and the value
        #return false if it is not in it
        print("BEGIN")
        if attack_name not in self.possible_attacks:
            return False
        if attack_name in self.attacks:
            return False
        attacks_list = []
        keys_to_remove = []
            #setting the value associated to the key to the key in attacks
        if(len(self.attacks) < 4):
            #self.attacks[attack_name] = self.possible_attacks[attack_name]
            self.attacks[attack_name] = self.possible_attacks[attack_name]
            return True
            
        for i in self.attacks:
            attacks_list.append(i)
        attacks_list.sort()
        print("before removal: ", attacks_list)
        
        if(len(self.attacks) >= 4):
            #if the length of self.attacks == 4, drop the attack that has the smallest value
            min_val = 100
            for val in self.attacks.values():
                if(min_val > val):
                    min_val = val
            print("min_val", min_val)
            for key in self.attacks.keys():
                if(self.attacks[key] == min_val):
                    keys_to_remove.append(key)
            keys_to_remove.sort()
            print(keys_to_remove)
            key_to_remove = keys_to_remove.pop(0)
            for key in self.attacks:
                if(key == key_to_remove):
                    del self.attacks[key]
                    break
            self.attacks[attack_name] = self.possible_attacks[attack_name]
            #self.remove_attack(key_to_remove)
            attacks_list.remove(key_to_remove)
            #self.attacks[attack_name] = self.possible_attacks[attack_name]
            print("after removal: ", attacks_list)
            for key, value in self.attacks.items():
                print(key, ": ", value)
            print("TRUE add")
            return True
        
    
        #min_value = 100  This is the previous value in the dictionary
        # for key, value in self.attacks.item()
        # if value < min_value, then make the min_value = value and min_key = key
        # can look ip pythn ord
        #can compare the first letter of the key with another character. returns true if the character comes before the other alphabetically
        #   if value == minimum value and if the first char of key is < min_key, then you drop that attack in the dict
        
        #can drop by pop or del that key value from dict del(self.attacks[key])
        #to add to dict, self.attacks[attack_name] = self.possible_attacks[attack_name]
        
    
    def remove_attack(self, attack_name):
        #check if attack is in self.attacks dict
        #del the attack name(the key) from the dict
        #if there no more attacks in dict, if empty length=0, then add back the wait attack
        
        if attack_name not in self.attacks:
            print("remove false")
            return False    
        else:
            del self.attacks[attack_name] 
            if(len(self.attacks) == 0):
                self.attacks['wait'] = 0
                print("lol")
            print("TRUE remove\n")
            return True
                
                
#monst = Monster('Rawr')
#print(monst.add_attack('slash'))
#print(monst.remove_attack('slash'))

#print(monst.add_attack('ice_storm'))
#print(monst.add_attack('sneak_attack'))
#print(monst.add_attack('tornado'))
#print(monst.add_attack('earthquake'))

        