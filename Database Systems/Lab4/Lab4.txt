Claire Ruffing 
CSE180 Lab 4 
5/29/20

C1: 
alter table actors add constraint c1 check((name ~ '^[A-Z].*([\s][A-Z].*)+') AND (name !~ '.*[0-9].*') AND ((split_part(name, ' ', 1) ~ '[AEIOU].*[b-df-hj-np-tv-z].*') OR (split_part(name, ' ', 1) ~ '[B-DF-HJ-NP-TV-Z].*[aeiou].*')) AND ((split_part(name, ' ', 2) ~ '[AEIOU].*[b-df-hj-np-tv-z].*') OR (split_part(name, ' ', 2) ~ '[B-DF-HJ-NP-TV-Z].*[aeiou].*')));

C2:
alter table actors add constraint c2 check((2020-birthyear) between 10 and 100);

C3:
alter table actors add constraint c3 check(gender IN ('Female', 'Male', 'Non-binary'));

C4:
alter table reviews add constraint c4reviews check((length(review_text)<=2000) AND (length(review_text)-length(replace(review_text, '.', ''))<=20) AND (length(review_text)-length(replace(review_text, ' ', ''))<1000) AND (review_text ~ '[A-Z].*'));

C5:
alter table reviews add constraint c51 check(rating between 1.0 and 10.0);
alter table imdb add constraint c52 check(imdb_rating between 1.0 and 10.0);

C6:
alter table movieroles drop constraint movieroles_actorid_fkey;
alter table movieroles add constraint movieroles_actorid_fkey foreign key (actorid) references actors(actorid) on delete cascade;
alter table movieroles drop constraint movieroles_movieid_fkey;
alter table movieroles add constraint movieroles_movieid_fkey foreign key (movieid) references movies(movieid) on delete cascade;
alter table reviews drop constraint reviews_movieid_fkey;
alter table reviews add constraint reviews_movieid_fkey foreign key (movieid) references movies(movieid) on delete cascade;
alter table imdb drop constraint imdb_movieid_fkey;
alter table imdb add constraint imdb_movieid_fkey foreign key (movieid) references movies(movieid) on delete cascade;
delete from movies where movieid=7;
delete from actors where actorid=5;

C7:
(violates C1): insert into actors values (15, 'Cj Parker', 'Male', 1928);
 (violates C2): insert into actors values (14, 'Amy Curtis', 'Female', 1900);
 (violates C3): insert into actors values (16, 'Bob White', 'Alien', 1944);
 (violates C4): insert into reviews values (20, 10, 5, 'everything happens for a reason.');
 (violates C5): insert into reviews values (21, 11, 16.5, 'Everything happens for a reason.');
                insert into imdb values (12, 22.7, 'tt1516021');

C8:
select * from movies M1, movies M2 where M1.title=M2.title AND M1.genre=M2.genre AND M1.director<>M2.director;
The functional dependency {title, genre} -> {director} does not hold in the movies table because it does not return the empty set. It does not return the empty set because PostgreSQL detected duplicates for the title 'The Thing' and genre Horror, Mystery, Sci-Fi with unique directors. 

C9:
select * from actors A1, actors A2 where A1.name=A2.name AND A1.gender=A2.gender AND A1.birthyear<>A2.birthyear;
The functional dependency {name, gender} -> {birthyear} holds in the movies table because it returns the empty set. It returns the empty set because PostgreSQL detected no duplicates for names and genders matching with unique birthyears. 

C10: 
 (C8): delete from movies where movieid=0;
       select * from movies M1, movies M2 where M1.title=M2.title AND M1.genre=M2.genre AND M1.director<>M2.director;
 This would violate C8 because this would return the empty set verifying that there are no duplicates while C8 says there are duplicates.
 (C9): insert into actors values(14, 'Emma Stone', 'Female', 1963);
       select * from actors A1, actors A2 where A1.name=A2.name AND A1.gender=A2.gender AND A1.birthyear<>A2.birthyear;
 This would violate C9 because this returns duplicates for the name 'Emma Stone' and gender 'Female', whereas C9 returns the empty set which indicates there are no duplicates.


Q1:
insert into movies values (10, 'Lord of the Rings', 'Fantasy, Action', 2001, 'Peter Jackson');
insert into actors values (15, 'Orlando Bloom', 'Male', 1977);
insert into movieroles values (15, 10, 'Legalus');
insert into reviews values (10, 10, 3, 'You shall not pass.');
insert into imdb values (10, 9, 'tt1327268');

Q2:
select title, imdbid, rating, CASE when movies.movieid>9 then 'True' else 'False' END AS "New Movie"
from movies, imdb, reviews 
where movies.movieid=reviews.movieid AND movies.movieid=imdb.movieid
group by title, imdbid, rating, movies.movieid;

Q3:
select name, case when name='Orlando Bloom' then 'True' else 'False' end as "New Actor"
from actors
group by name;

Q4:
select role, case when name='Orlando Bloom' OR title='Lord of the Rings' then 'True' else 'False' end as "New Role"
from movieroles, movies, actors where actors.actorid=movieroles.actorid AND movieroles.movieid=movies.movieid
group by role, name, title;

Q5:
select name, birthyear, case when birthyear>1970 then 'Young' else 'Old' end as "Actor Age"
from actors
group by name, birthyear
order by name;

For Q5, I am expecting a table of all of the actor names and a column called "New Role" that determines if an actor is young if their birthyear is greater than 1970 and old if their birthyear is 1970 or before.

