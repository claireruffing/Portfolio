#!/usr/bin/perl
# $Id: pmake,v 1.39 2021-05-21 18:35:44-07 - - $
# Claire Ruffing cmruffin@ucsc.edu

$0 =~ s|.*/||;
use Getopt::Std;
use Data::Dumper;
use strict;
use warnings;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
# dump_hash prints out the hashtable
sub dump_hash ($\%) {
   my ($label, $hashptr) = @_;
   print STDERR "%$label: ", Data::Dumper->Dump ([$hashptr]);
}

my $STATUS = 0;
END { exit $STATUS; }
$SIG{'__WARN__'} = sub { print STDERR @_; $STATUS = 1; };
$SIG{'__DIE__'} = sub { print STDERR @_; $STATUS = 1; exit; };

# sigtoperl: x86_64 Linux unix1.lt.ucsc.edu
# sigtoperl: Sun Nov 22 17:33:55 2020
my %strsignal = (
    0 => "Unknown signal 0",
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   10 => "User defined signal 1",
   11 => "Segmentation fault",
   12 => "User defined signal 2",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   23 => "Urgent I/O condition",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

# Whenever you detect a command in the Makefile, you can call
# run_command to execute that command and print the command itself.
# Need to modify this. pass in another parameter that indicates whether
# or not the print command should be executed (line 71)
# Or alternatively delete line 69 and inside of make_goal you can
# print the command returns undef if false or a string if true
sub run_command ($) {
   my ($command) = @_;
   # print "$command\n";
   # print "\t\tCOMMAND IM RUNNING IS", $command, "\n";
   # Grabs the status by passing command into system
   # and gets back the 16 bit number
   my $status = eval {no warnings; system $command};

   # print("status is ", $status, "\n");
   # returns undefined if ran successsfully (would be 0)
   return undef unless $status;
   # otherwise returns error statement
   return "$!" if $status == -1;
   my $signal = $status & 0x7F;
   my $core = $status & 0x80;
   my $exit = ($status >> 8) & 0xFF;
   # print("we are here ", $signal, $core, $exit, "\n");
   # returns error exit when signal and core is 0
   return "Error $exit" unless $signal || $core;
   # getting the signal for the error code and get the appropriate
   # error message or else invalid signal.
   # core status code tells you if the core was dumped or not
   return ($strsignal{$signal} || "Invalid Signal Number $signal")
        . ($core ? " (core dumped)" : "");
}

# Variable
my $MAKECMDGOALS;
my $Makefile = "Makefile";
# The following are 3 graphs
# A set of flags
my %OPTIONS;
# The graph of dependencies
# Key: target name -> LINE -> Line number of definition, PREREQS
   # -> array of prereq strings, COMMANDS -> array of commands
my %GRAPH;
# The macros that have been defined
# Key: macro name -> LINE -> Line number of definition, VALUE
   # -> The macro assignment
my %MACROS;


sub usage() { die "Usage: $0 [-mgd] [target]\n" }
# Stops the Makefile immediately
sub stop($) { die "$Makefile:@_. Stop.\n" }

# sets the options graph, and makecmdgoals is argv[0]
# if it exists $MAKECMDGOALS is whats in command line
# after make like foo in $ make foo
sub scan_cmdline() {
   getopts "dgm", \%OPTIONS;
   usage unless @ARGV <= 1;
   $MAKECMDGOALS = $ARGV[0] if @ARGV == 1;
}

# for debugging to print out data at runtime
sub dump_graph() {
   print STDERR "%MACROS:\n";
   for my $macro (sort keys %MACROS) {
      printf STDERR "%7d [%s] = [%s]\n",
             $MACROS{$macro}{LINE}, $macro, $MACROS{$macro}{VALUE};
   }
   print STDERR "MAKECMDGOALS = [$MAKECMDGOALS]\n";
   print STDERR "%GRAPH:\n";
   for my $target (sort keys %GRAPH) {
      # $prereqs is a pointer to the array
      my $prereqs = $GRAPH{$target}{PREREQS};
      printf STDERR "%7d [%s] :", $GRAPH{$target}{LINE}, $target;
      print STDERR " [$_]" for @$prereqs;
      print STDERR "\n";
      for my $cmd (@{$GRAPH{$target}{COMMANDS}}) {
         printf STDERR "%7d.\t[%s]\n", $cmd->{LINE}, $cmd->{CMD};;
      }
   }
}

# the entirety of the parser which is already done for us
# Loads the graph and the macros hash tables
sub load_Makefile() {
   open my $mkfile, "<$Makefile" or die "$0: $Makefile: $!";
   my $target;
   while (defined (my $line = <$mkfile>)) {
      # If the line begins with a hash, we skip to the next line
      next if $line =~ m/^\s*(#|$)/;
      # If the target isnt there and the line matches exactly
      # something with an equal sign in it, then we have
      # defined a macro.
      if (!$target && $line =~ m/^\s*(\S+)\s*=\s*(.*?)\s*$/) {
         $MACROS{$1} = {LINE=> $., VALUE=> $2};
      }elsif ($line =~ m/^(\S+)\s*:\s*(.*)/) {
         # Otherwise if the line matches something with a
         # colon in it, then we set the target equal to
         # the first token
         # Do check for macros here, do on target and each prereq
         $target = $1;
         my $preq = [split ' ', $2];

         # print("Target before is ", $target, "\n");

         # If the target is a macro, replace it with its value
         if($target =~ m/\$\{([A-Z]+)\}/) {
            # my $val = $target;
            $target =~ s/\${(.*?)}/$MACROS{$1}{VALUE}/ge;
            # print("Target after is ", $target, "\n");
         }

         # If the prereq is a macro, replace it with its value
         for my $p (@$preq) {
            # print("Prereq before is ", $p, "\n");
            # Calling function macro_substitution which changes the
            # prereq macro to its value
            if($p =~ m/\$\{([A-Z]+)\}/) {
               $p =~ s/\${(.*?)}/$MACROS{$1}{VALUE}/ge;
               $GRAPH{$target}{PREREQS} = [split ' ', $p];
            }
            else {
               $GRAPH{$target}{PREREQS} = $preq;
            }
         }
         $GRAPH{$target}{LINE} = $.;
         $MAKECMDGOALS = $target unless $MAKECMDGOALS;
      }elsif ($line =~ m/^\t(.*)/) {
         # Any lines that begin with a tab, we push onto the
         # graph with a particular target and the commands
         if (defined $target) {
            # push requires an array as its first arg like in x.perl
            my $strc = [split ' ', $1];
            my $comd = $1;
            # print("Command strc is ", $strc, "\n");
            for my $w (@$strc) {
               # print("Each WORD in command is ", $w, "\n");
               if($w =~ m/\$\{([A-Z]+)\}/) {
                  # $w =~ s/\${(.*?)}/$MACROS{$1}{VALUE}/ge;
                  $comd =~ s/\${(.*?)}/$MACROS{$1}{VALUE}/ge;
               }
            }
            # print("Dollar 1 is ", $1, "\n");
            # print("Command comd is ", $comd, "\n");
            push @{$GRAPH{$target}{COMMANDS}},
                 {LINE=> $., CMD=> $comd};
         }else {
            stop "$.: Command before first target";
         }
      }else {
         stop "$.: Missing separator";
      }
   }
   close $mkfile;
}


sub modtime ($) {
   my ($filename) = @_;
   my @stat = stat $filename;
   # $stat[9] holds the modtime
   # return $stat[9];
   # if @stat is true then return $stat[9] else return undef
   return @stat ? $stat[9] : undef;
}

my @visited;
# newest time is prereq time variable
my $newptime = 0;
# newest time is target time variable
my $newttime = 0;

# forward declaration before writing the function
sub make_goal($);

sub make_goal($) {
   my ($goal) = @_;

   # print("goal at top is ", $goal, "\n");
   # If the goal has already been visited, mark as visited
   if((scalar @visited) >= 1) {
      for my $v (@visited) {
         if($goal eq $v) {
            # print("goal has already been visited", "\n");
            return 0;
         }
      }
   }
   push(@visited, $goal);
   # print("visited is ", @visited, "\n");
   my $isGoalTarget = 0;
   my $target;
   for my $tg (sort keys %GRAPH) {
      # print("x is", $x, "\n");
      if($goal eq $tg) {
         $isGoalTarget = 1;
         $target = $tg;
         last;
      }
   }
   # print("target is ", $target, "\n");
   # print("goal is ", $goal, "\n");
   # if goal is not a target
   if($isGoalTarget == 0) {
      my $gtime = modtime($goal);
      if(defined($gtime)) {
         return $gtime;
      }
      else {
         # print("goal ", $goal, " is not a target", "\n");
         print("No rule to make for target", "\n");
         return 0;
      }
   }
   # if goal is a target
   if($isGoalTarget == 1) {
      # print("goal is a target", "\n");
      my $prereqs = $GRAPH{$goal}{PREREQS};
      # print("prereqs is ", @$prereqs, "\n");
      # print("prereqs[0] is ", @$prereqs[0], "\n");
      my @prereqtimes;
      my $ptime = 0;
      my $ttime = 0;
      for my $prq (@$prereqs) {
         # Check here if the prereqs are targets and if they
         # are, recursively call them
         # print("prereq is ", $prq, "\n");
         my $isTarget = 0;
         for my $x (sort keys %GRAPH) {
            # print("x is", $x, "\n");
            if($prq eq $x) {
               $isTarget = 1;
               last;
            }
         }
         # Call modtime on each prereq and the target
         # itself and check which is newest time checking
         # if target or prereq was modified sooner.
         # If there are no prereqs, the modtime for them is 0
         $ptime = modtime($prq);
         if(!defined($ptime)) {
            $ptime = 0;
         }
         # print("goal here is ", $goal, "\n");
         # print("target here is ", $target, "\n");
         $ttime = modtime($target);
         if(!defined($ttime)) {
            $ttime = 0;
         }
         # print("targettime is ", $ttime, "\n");
         # If the target file exists
         # print("ptime is ", $ptime, "\n");
         # If the prerequisite is newer than the target
         # modtime, set the newesttime to be prereq time.
         if($ptime > $ttime) {
            $newptime = $ptime;
            # print("newesttime is ptime ", $newptime, "\n");
         }
         # If the target modtime is newer than the prerequisite,
         # then set the newest time to be target time.
         elsif ($ttime > $ptime) {
            $newttime = $ttime;
            # print("newesttime is targettime ", $newttime, "\n");
         }
         else {
            $ptime = 0;
            $ttime = 0;
         }

         # If prereq is a target, recurse to make prereq the goal
         if($isTarget == 1) {
            # print("prereq is a target! so recurse", "\n");
            make_goal($prq);
         }

      }

      # Getting the cmd to be used to run the command
      my $cmd;
      for my $command (@{$GRAPH{$goal}{COMMANDS}}) {
         # printf STDERR "%7d.\t[%s]\n", $cmd->{LINE}, $cmd->{CMD};;
         $cmd = $command->{CMD};
         # store the cmd scalar in another variable
      }

      # If the target time is greater than the ptime
      if($newttime > $newptime) {
         # If there is a cmd then return its modtime
         if(defined $cmd) {
            print("make: ", "'", $target, "'", " is up to date", "\n");
            return $ttime;
         }
         # Else if theres no cmd, then return 0
         else {
            # print("HEREEE", "\n");
            return 0;
         }
      }

      # If the newest prereq is newer than the target modtime,
      # run the command.
      # If the target file does not exist, run the command.
      # Else if the target modtime is newer than the newest prereq,
      # don't run the command.
      if(($newptime > $newttime) || ($ttime == 0)) {

         my $rtcode = 0;
         # before you print command here, check for the @ and - signs
         # have scalar to inidcate if @ or - and based on the scalar
         # can have if statement if sclar is 0, print and run command,
         # if 1 just run command print, runcommand, and then check the
         # rtcode for error
         # print("Goal is ", $goal, "and Command is ", $cmd, "\n");
         # If the command does not begin with a @ sign, print it.
         # Otherwise don't.
         if(defined $cmd) {
            # print("COMMAND BEFORE CMD IS ", $cmd, "\n");
            if(($cmd =~ m/^\@.*/) || ($cmd =~ m/^\-.*/)) {
               my $newStr = substr($cmd, 2);
               # print("New String is ", $newStr);
               if($cmd =~ m/^\-.*/) {
                  print($newStr, "\n");
               }
               $rtcode = run_command($newStr);
            }
            else {
               print($cmd, "\n");
               $rtcode = run_command($cmd);

            }

            if(defined $rtcode){
               if($cmd =~ m/^\-.*/) {
                  print("Ignored: ", $rtcode, "\n");
               }
               else {
                  # print("printing rtcode here", "\n");
                  print("Error file does not exist", "\n");
               }
            }
         }

      }

   }

}

scan_cmdline;
load_Makefile;

dump_hash ("MACROS", %MACROS) if $OPTIONS{'m'};
dump_hash ("GRAPH", %GRAPH) if $OPTIONS{'g'};
dump_graph if $OPTIONS{'d'};


make_goal ($MAKECMDGOALS);

