#Now we want a way to make our monsters fight!

Before two monsters can fight, we need to give 2 new class methods that update their stats. Implement a method for “win_fight” and “lose_fight”. Win_fight should add 5 to the monster’s self.exp and reset their hp to max_hp. “lose_fight” should also reset their hp but only adds 1 exp to self.exp.

Now write a function that takes 2 instances of the monster class and makes them fight. This function should be defined outside the Monster class, i.e. it is not a Monster method. A fight goes as follows:

The monster that entered as the first function goes first.
Each monster takes a turn using one attack move. The monster selects this attack move from the strongest to the weakest in a circular function.
For example:

A monster has a dictionary of possible attack as follows:

[“fire_storm”: 3, “double_hit”: 4, “earthquake”: 2, “ice_storm”: 3]

An attack is always successful and will decrease the opponent’s hp by the given number of points in self.attacks dictionary. The monsters continue taking turns until their current hp becomes less than or equal to zero.
At this point, the win_fight and lose_fight method should be invoked. Once this complete, return 3 things from the function.
Round_number
Monster that won (return the corresponding Monster object)
List of attacks the monster used
Special Edge Case: If both monster only have “wait” as an attack, return

-1 (round_number)
None (for monster name that won)
None (for list of attack that monster use)


#CODE
class Monster():
    def __init__(self, name, maxhp=20, ty='Normal'):
        self.exp = 0
        self.name = name
        self.max_hp = maxhp
        self.type = ty
        self.current_hp = self.max_hp
        self.attacks = { 
            'wait' : 0
        }
        self.possible_attacks = {
            'sneak_attack' : 1,
            'slash' : 2,
            'ice_storm' : 3,
            'fire_storm' : 3,
            'whirlwind' : 3,
            'earthquake' : 2,
            'double_hit' : 4,
            'tornado' : 4,
            'wait' : 0
        }
            
    def add_attack(self, attack_name):
        #check if this string attack_name is in self.possible_attacks.key() (Note: .item() returns the key and the value
        #return false if it is not in it
        if attack_name not in self.possible_attacks:
            return False
        if attack_name in self.attacks:
            return False
        attacks_list = []
        keys_to_remove = []
            #setting the value associated to the key to the key in attacks
        if(len(self.attacks) < 4):
            #self.attacks[attack_name] = self.possible_attacks[attack_name]
            self.attacks[attack_name] = self.possible_attacks.get(attack_name)
            return True
            
        for i in self.attacks:
            attacks_list.append(i)
        attacks_list.sort()
        
        if(len(self.attacks) >= 4):
            #if the length of self.attacks == 4, drop the attack that has the smallest value
            min_val = 100
            for val in self.attacks.values():
                if(min_val > val):
                    min_val = val
            for key in self.attacks.keys():
                if(self.attacks[key] == min_val):
                    keys_to_remove.append(key)
            keys_to_remove.sort()
            key_to_remove = keys_to_remove.pop(0)
            for key in self.attacks:
                if(key == key_to_remove):
                    del self.attacks[key]
                    break
            self.attacks[attack_name] = self.possible_attacks.get(attack_name)
            #self.remove_attack(key_to_remove)
            attacks_list.remove(key_to_remove)
            #self.attacks[attack_name] = self.possible_attacks[attack_name]
           #for key, value in self.attacks.items():
            #    print(key, ": ", value)
            return True
        
    
        #min_value = 100  This is the previous value in the dictionary
        # for key, value in self.attacks.item()
        # if value < min_value, then make the min_value = value and min_key = key
        # can look ip pythn ord
        #can compare the first letter of the key with another character. returns true if the character comes before the other alphabetically
        #   if value == minimum value and if the first char of key is < min_key, then you drop that attack in the dict
        
        #can drop by pop or del that key value from dict del(self.attacks[key])
        #to add to dict, self.attacks[attack_name] = self.possible_attacks[attack_name]
        
    
    def remove_attack(self, attack_name):
        #check if attack is in self.attacks dict
        #del the attack name(the key) from the dict
        #if there no more attacks in dict, if empty length=0, then add back the wait attack
        if attack_name not in self.attacks:
            #print("remove false")
            return False    
        else:
            del self.attacks[attack_name] 
            if(len(self.attacks) == 0):
                self.attacks['wait'] = 0
               # print("lol")
            #print("TRUE remove\n")
            return True 

    def win_fight(self):
        #Win_fight should add 5 to the monster's self.exp and reset their hp to max_hp
        self.exp = self.exp + 5
        self.current_hp = self.max_hp
    
        #print(self.exp)
        print("winnerhp: ", self.current_hp)
    
    
    def lose_fight(self):
        #"lose_fight" should also reset their hp but only adds 1 exp to self.exp.
        self.exp = self.exp + 1
        self.current_hp = self.max_hp
        #print("loser: ", self.exp)
        print("loserhp: ", self.current_hp)
        
      
def monster_fight(monster1, monster2):
    #The monster that entered as the first function goes first.
    #Each monster takes a turn using one attack move. 
    #The monster selects this attack move from the strongest to the weakest in a circular function.
    #An attack is always successful and will decrease the opponent's hp by the given number of points in self.attacks dictionary. 
    #The monsters continue taking turns until their current hp becomes less than or equal to zero.
    #At this point, the win_fight and lose_fight method should be invoked. Once this complete, return 3 things from the function.
    #when working on the special cases, make a list
    
    #list of keys, and list of values
    #if monster1 turn, you decrement monster2 hp by monster 1 attack val
    #keep a counter per monster per round. counter goes up if monster still alive. if monster dies, counter does not go up.
    #But the monster that killed the other monster gets to have his counter go up bc hes still alive.
    #keeps fighting until one monster dies. then break out of while loop (while hp > 0)
    #Once one dies, assign killed monster to lost fight and the winner to win fight
    #the list you return is the list of attacks used in the fight
    
    m1keys_list = []
    m1values_list = []
    m2keys_list = []
    m2values_list = []
    temp1_list = []
    temp2_list = []
    
    print("HELLO")
    print("monster1 hp: ", monster1.current_hp)
    print("monster2 hp: ", monster2.current_hp)
    #print("m1keys list before add attack: ", m1keys_list)
    #print("m1values list before add attack: ", m1values_list)
        
    #list of keys and values for monster1
    for key, value in monster1.attacks.items():
        m1keys_list.append(key)
        m1values_list.append(value)
    m1keys_list.sort()
    temp1_list = m1keys_list[:]
    m1values_list.sort(reverse=True)
    print("m1keys list before add attack: ", m1keys_list)
    print("m1values list before add attack: ", m1values_list)
    
    #list of keys and values for monster2
    for key, value in monster2.attacks.items():
        m2keys_list.append(key)
        m2values_list.append(value)
    m2keys_list.sort()
    temp2_list = m2keys_list[:]
    m2values_list.sort(reverse=True)
    print("m2keys list before add attack: ", m2keys_list)
    print("m2values list before add attack: ", m2values_list)
    
    flag1 = False
    flag2 = False
    #if both monsters only have wait as an attack
    for key in m1keys_list:
        if((monster1.attacks[key] == 0) and (len(m1keys_list) == 1)):
            flag1 = True
    for key in m2keys_list:
        if((monster2.attacks[key] == 0) and (len(m2keys_list) == 1)):
            flag2 = True
    if((flag1 == True) and (flag2 == True)):
        return(-1, None, None)
 
    #if monster1 turn, you decrement monster2 hp by monster 1 attack val
    m1_counter = 0
    m2_counter = 0
    #round_number = 0
    round_number = 0
    i = 0
    m1_attacks_used = []
    m2_attacks_used = []
    while((monster1.current_hp > 0) and (monster2.current_hp > 0)):
        print("temp1_list: ", temp1_list)
        print("m1keyslist: ", m1keys_list)
        print("temp2_list: ", temp2_list)
        if(i == len(m1values_list)):
            i = 0
            temp1_list = m1keys_list[:]
            temp2_list = m2keys_list[:]
            print("temp1_list: ", temp1_list)
            print("temp2_list: ", temp2_list)

        #when it is monster1 turn
        m1_val = m1values_list[i]
        print("m1val: ", m1_val)
        for key in temp1_list:
            if(monster1.attacks[key] == m1_val):
                m1_attacks_used.append(key)
                temp1_list.remove(key)
        monster2.current_hp = monster2.current_hp - m1_val
        print("current_hp2: ", monster2.current_hp)
        if(monster2.current_hp > 0):
            m1_counter = m1_counter + 1
        else: 
            m2_counter = m2_counter - 1
            m1_counter = m1_counter + 1
            print("m1 turn")
            round_number = round_number + 1
            break
        #when it is monster2 turn
        m2_val = m2values_list[i]
        print("m2val: ", m2_val)
        for key in temp2_list:
            if(monster2.attacks[key] == m2_val):
                m2_attacks_used.append(key) 
                temp2_list.remove(key)
                break
        monster1.current_hp = monster1.current_hp - m2_val
        print("current_hp1: ", monster1.current_hp)
        if(monster1.current_hp > 0):
            m2_counter = m2_counter + 1
        else:
            m1_counter = m1_counter - 1
            m2_counter = m2_counter + 1
            print("m2 turn")
            round_number = round_number + 1
            break
        round_number = round_number + 1
        i = i + 1
       
    print("m1counter: ", m1_counter)
    print("m2counter: ", m2_counter)
    if(m1_counter > m2_counter):
        print("winner is monster1")
        monster1.win_fight()
        monster2.lose_fight()
        print("m1round_number is: ", round_number)
        print("m1attacks_used is :", m1_attacks_used)
        print("YUH")
        return(round_number, monster1, m1_attacks_used)
    elif(m1_counter < m2_counter):
        print("winner is monster2")
        monster2.win_fight()
        monster1.lose_fight()
        print("m2round_number is: ", round_number)
        print("m2attacks_used is :", m2_attacks_used)
        print("YUH2")
        return(round_number, monster2, m2_attacks_used)
        

if __name__ == '__main__':
    foo = Monster("foo", 8)
    bar = Monster("bar", 6)
    foo.add_attack("fire_storm")
    foo.add_attack("earthquake")
    foo.add_attack("tornado")
    bar.add_attack("sneak_attack")
    bar.add_attack("slash")
    foo.win_fight()
    foo.lose_fight()
    if str(foo.attacks) != "{'wait': 0, 'fire_storm': 3}":
        print("attacks didn't add correctly")
    bar.add_attack("whirlwind")
    
    drag = Dragon()
    gho = Ghost()
    
    rounds, winner, winner_moves_used = monster_fight(foo, bar)
    #if rounds != 2:
    #    print("wrong number of rounds: have {}, expected 2".format(rounds))
    if winner != foo:
        print("wrong winner: have {}, expected foo".format(foo))
    print("winner_moves_used: {}".format(str(winner_moves_used)))
